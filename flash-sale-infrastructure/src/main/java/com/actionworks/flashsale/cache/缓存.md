# 缓存设计原则
* 热点数据一律进缓存；
* 缓存场景一律采取本地缓存+分布式缓存的综合方案；
* 优先读取本地缓存，以本地缓存为主，远端分布式缓存为辅；
* 所有缓存设置过期时间，本地缓存过期时间控制在秒级；
* 本地缓存务必同时设置容量驱逐和时间驱逐两种方式；
* 缓存KEY具有业务可读性，杜绝不同场景出现相同KEY；
* 缓存列表数据时，仅缓存第一页，缓存数量不超过20；
* 杜绝并发更新缓存，防止缓存击穿；
* 空数据进缓存，防止缓存穿透；
* 读数据时，先读缓存，再读数据库；
* 写数据时，先写数据库，再写缓存。

# 缓存生命周期设计策略
1. 更新策略
* 被动更新：本地缓存过期后被驱逐；
* 主动更新：请求传入的版本号大于本地缓存的版本号，意味着本地缓存的数据滞后，需要从分布式缓存中重新获取。
2. 过期时间
在缓存的设计原则中，所有的缓存都应该设置过期时间。相比于本地缓存，分布式缓存的过期时间要稍微长一些，并且在更新机制上与本地缓存略有不同
   * 被动刷新：基于Redis的数据驱逐策略，包括LRU和TTL等；
   * 主动刷新：业务数据驱动的数据更新。当业务侧有数据变更时，将会主动刷新分布式缓存。比如当秒杀品下线时，会发出相应的领域事件，而在领域事件的处理中就会刷新缓存。